---
category: 技术分享
comments: true
date: '2025-08-05'
description: ''
draft: false
lastMod: '2025-08-05'
sticky: 0
summary: ''
tags:
- 博客
title: 未命名文章
---

---
## 单例模式在Unity中的概念与用途
- **定义**：确保某个类在整个游戏运行周期内只有一个实例，并可全局访问此实例。
- **常见场景**：
  - **GameManager**：控制全局游戏状态、分数、关卡。
  - **AudioManager**：统一管理音乐和音效播放。
  - **UIManager**：统一管理全局UI元素的显示与更新。

## 使用泛型与继承实现可复用的单例基类
通过C#泛型（Generics）与继承（Inheritance），可以创建一个通用的单例基类，然后针对不同的Manager类进行特化，无需重复编写单例逻辑。

### 基类声明示例（伪代码简述）
```csharp
public class Singleton<T> : MonoBehaviour where T : MonoBehaviour
{
    protected static T m_instance;
    public static T instance
    {
        get
        {
            if (m_instance == null)
            {
                m_instance = FindObjectOfType<T>();
                if (m_instance == null)
                {
                    // 场景中不存在则动态创建
                }
            }
            return m_instance;
        }
    }

    protected virtual void Awake()
    {
        if (instance != this)
        {
            Destroy(gameObject);
            return;
        }
        DontDestroyOnLoad(gameObject);
    }
}
```

**关键点**：
- `T`是泛型类型参数，占位用，约束`T`必须是`MonoBehaviour`，使其具备Unity脚本特性。
- `instance`属性负责全局唯一实例的获取，如果不存在则在场景中查找或创建。
- `Awake()`中检查重复实例，多余的对象会被销毁。
- 使用`virtual`可让子类`override Awake()`以添加自定义初始化逻辑。

### 子类使用方法（伪代码简述）
```csharp
public class GameManager : Singleton<GameManager{
    protected override void Awake()
    {
        base.Awake();
        // 可在此添加GameManager的初始化逻辑
    }
}
```

通过这种写法，`GameManager`自动获得单例逻辑，无需重复编码。

## 泛型、继承、虚函数三者的关系
- **泛型（Generics）**：
  提供一个“模板”，`Singleton<T>`能适应不同的`MonoBehaviour`子类，不必为每个Manager类单独写单例代码。

- **继承（Inheritance）**：
  `Singleton<T>`继承`MonoBehaviour`，保证其为Unity脚本，子类如`GameManager`继承`Singleton<GameManager>`即可同时获得MonoBehaviour特性和单例功能。

- **虚函数（Virtual Function）**：
  `Awake()`被定义为`virtual`，子类可通过`override`在保持单例逻辑的基础上扩展初始化细节。

## 注意事项
- **避免滥用**：单例虽然方便，但过度使用会增加耦合，降低可测试性。
- **确保唯一性**：通过`Awake()`中的检测和销毁逻辑确保全局只有一个实例。
- **轻松扩展**：为不同的Manager类快速实现单例模式，减少重复编码，提高项目结构的清晰度与可维护性。