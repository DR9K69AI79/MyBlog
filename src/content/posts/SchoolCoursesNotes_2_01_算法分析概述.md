---
title: DMT211_算法-01-算法分析概述
date: 2024-04-09
summary: 本课程介绍算法的基本概念、重要性以及算法设计技术。涵盖算法分析的基础知识，包括时间效率、空间效率、最优性等核心概念，以及常见的问题类型如排序、搜索、字符串处理等。
category: DMT211_Algorithm Analysis and Design
tags:
  - 课程笔记
  - 算法基础
  - 算法分析
comments: true
draft: false
sticky: 0
---
# 算法分析概述

## 什么是算法(algorithm)？

算法是一系列明确的指令，用于在有限的时间内解决一个问题，即对于任何合法的输入，得到所需的输出。
- 算法的输入指定了算法所解决问题的一个实例。
- 算法可以用以下方式指定：
  - 自然语言
  - 伪代码(pseudocode)
  - 混合使用自然语言和类似编程语言的结构

## 为什么要学习算法？

算法在许多领域都有广泛而深远的影响，例如：

- 互联网：网络搜索、数据包路由、分布式文件共享等
- 人工智能：无人驾驶、计算机视觉等
- 计算机：电路布局、文件系统、编译器等
- 计算机图形学：电影、视频游戏、虚拟现实等
- 安全：手机、电子商务、投票机等
- 多媒体：MP4、JPG、DivX、HDTV、人脸识别等
- 社交网络：推荐、新闻推送、广告等
- 物理：空气动力学模拟、粒子碰撞模拟等
- 生物：人类基因组计划、蛋白质折叠等

此外，学习算法还有以下原因：

- 智力刺激
- 成为一名熟练的程序员
- 它们可能解开生命和宇宙的奥秘
- 兴趣和利益

## 算法分析和设计的过程

1. 问题 -> 算法设计 -> 编程 -> 算法分析 -> 问题

## 示例：计算两个整数的最大公约数(greatest common divisor, gcd)

问题：找到两个非负整数 $m$ 和 $n$ 的最大公约数 $gcd(m,n)$，其中 $m$ 和 $n$ 不同时为零。

- $gcd(m,n)$：能整除 $m$ 和 $n$ 的最大整数。

示例：
- $gcd(60,24) = 12$
- $gcd(60,0) = 60$

三种不同的方法：
1. 欧几里得算法(Euclid's algorithm)
2. 连续整数检查算法(Consecutive integer checking algorithm)
3. 中学方法(Middle-school procedure)

### 欧几里得算法计算 $gcd(m,n)$

欧几里得算法基于重复应用等式：

$$
gcd(m,n) = gcd(n, m \bmod n)
$$

直到 $m \bmod n$ 等于0。

算法步骤：
1. 如果 $n=0$，返回 $m$ 并停止；否则进入步骤2。
2. 用 $m$ 除以 $n$，将余数的值赋给 $r$。
3. 将 $n$ 的值赋给 $m$，将 $r$ 的值赋给 $n$。转到步骤1。

### 连续整数检查算法计算 $gcd(m,n)$

算法步骤：
1. 将 $\min\{m,n\}$ 的值赋给 $t$。
2. 用 $t$ 除 $m$。如果余数为0，进入步骤3；否则，进入步骤4。
3. 用 $t$ 除 $n$。如果余数为0，返回 $t$ 并停止；否则，进入步骤4。
4. 将 $t$ 减1，转到步骤2。

注：当其中一个输入数为0时，该算法无法正确工作。

### 中学方法计算 $gcd(m,n)$

算法步骤：
1. 找到 $m$ 的质因数分解。
2. 找到 $n$ 的质因数分解。
3. 找到所有共同的质因数。
4. 计算所有共同质因数的乘积，并将其作为 $gcd(m,n)$ 返回。

## 与算法相关的两个主要问题

1. 如何设计算法？
2. 如何分析算法的效率？

## 算法设计技术/策略

- 暴力法(Brute force)
- 分治法(Divide and conquer)
- 减治法(Decrease and conquer)
- 变换和征服(Transform and conquer)
- 贪心方法(Greedy approach)
- 动态规划(Dynamic programming)
- 回溯法(Backtracking)
- 分支限界法(Branch and bound)

## 算法分析

如何评估一个算法的好坏？
- 时间效率：时间复杂度(Time complexity)，表示算法运行的速度。
- 空间效率：空间复杂度(Space complexity)，指算法除了输入和输出所需的空间外，还需要的内存单元。

是否存在更好的算法？
下界(Lower bounds)：
- 下界指的是解决某个问题所需的最小时间或空间复杂度。
- 它为算法的效率提供了一个理论上的限制，即任何算法都不可能比下界更快或使用更少的空间。
- 通过证明问题的下界，我们可以知道是否还有改进算法效率的空间。

最优性(Optimality)：
- 如果一个算法的时间或空间复杂度与问题的下界相匹配，那么我们称这个算法是最优的。
- 最优算法是在给定的复杂度度量下，解决问题的最佳算法。
- 一旦我们证明了一个算法是最优的，那么我们就知道不可能找到一个更好的算法了。

## 重要的问题类型

- 排序(Sorting)
- 搜索(Searching)
- 字符串处理(String processing)
- 图问题(Graph problems)
- 组合问题(Combinatorial problems)
- 几何问题(Geometric problems)
- 数值问题(Numerical problems)

## 总结

- 算法：在有限时间内解决问题的一系列非歧义指令。
- 问题类型
- 设计技术
- 一个好的算法通常是反复努力和重做的结果。
- 同一问题通常可以用几种算法来解决。

## 练习

用伪代码描述将正十进制整数转换为二进制表示的标准算法。